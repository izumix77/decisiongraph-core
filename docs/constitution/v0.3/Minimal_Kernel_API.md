# DecisionGraph Core — Minimal Kernel API v0.3

**Normative Reference:** DecisionGraph Core Constitution v0.3
In case of conflict, the Constitution takes precedence.

This document describes the **implementation surface** of `@decisiongraph/core` under the
multi-graph model introduced in Constitution v0.3.

---

## Model Layers

- **Core Model (Normative):** Node / Edge / GraphStore semantics are defined by the Constitution v0.3.
- **Kernel (Deterministic):** Applies operations to produce a GraphStore state. The kernel does not "judge".
- **Policy (Enforcement):** Constitutional requirements are enforced via `ConstitutionalPolicy`.
- **Log Model (Transport):** A sequence of ops per Graph, identified by `graphId` (see JSON Schema v0.3).

---

## Design Principles

- Deterministic application: same inputs → same outputs
- No AI reasoning inside the kernel
- No random IDs generated by the kernel
- Constraints are explicit and enforceable (via policy)
- Single-graph GraphStore is fully v0.2 compatible

---

## 1) Core Types

### IDs

```ts
type NodeId   = Brand<string, "NodeId">;
type EdgeId   = Brand<string, "EdgeId">;
type AuthorId = Brand<string, "AuthorId">;
type CommitId = Brand<string, "CommitId">;
type GraphId  = Brand<string, "GraphId">;  // NEW in v0.3
```

ID generation is external to the kernel.
All IDs (NodeId, EdgeId, CommitId, GraphId) **MUST** be unique across the entire GraphStore.

### Status (unchanged)

- `NodeStatus`: `"Active" | "Superseded" | "Deprecated"`
- `EdgeStatus`: `"Active" | "Superseded" | "Deprecated"`

### Node / Edge / Commit (unchanged)

```ts
type Node = {
  id: NodeId;
  kind: string;
  status: NodeStatus;
  createdAt: string;   // ISO timestamp string
  author: AuthorId;
  payload?: unknown;
};

type Edge = {
  id: EdgeId;
  type: "depends_on" | "supports" | "refutes" | "overrides" | "supersedes";
  from: NodeId;        // MAY refer to a Node in a different Graph (cross-graph edge)
  to: NodeId;          // MAY refer to a Node in a different Graph (cross-graph edge)
  status: EdgeStatus;
  createdAt: string;   // ISO timestamp string
  author: AuthorId;
  payload?: unknown;
};

type Commit = {
  commitId: CommitId;
  createdAt: string;   // ISO timestamp string
  author: AuthorId;
};
```

### Graph (updated)

```ts
type Graph = {
  graphId: GraphId;    // NEW in v0.3 — stable identifier within GraphStore
  nodes: Record<string, Node>;
  edges: Record<string, Edge>;
  commits: Commit[];
};
```

### GraphStore (NEW in v0.3)

```ts
type GraphStore = {
  graphs: Record<string, Graph>;  // keyed by graphId
};

// Resolve a Node across all Graphs in the store
type ResolvedNode = { graphId: GraphId; node: Node };
type ResolvedEdge = { graphId: GraphId; edge: Edge };

function resolveNode(store: GraphStore, id: NodeId): ResolvedNode | null;
function resolveEdge(store: GraphStore, id: EdgeId): ResolvedEdge | null;
function emptyStore(): GraphStore;
```

---

## 2) Operations (unchanged from v0.2)

Operations target a specific Graph within the GraphStore (identified by `graphId`).

```ts
type AddNodeOp      = { type: "add_node"; node: Node };
type AddEdgeOp      = { type: "add_edge"; edge: Edge };
type SupersedeEdgeOp = {
  type: "supersede_edge";
  oldEdgeId: EdgeId;
  newEdge: Edge;
};
type CommitOp = {
  type: "commit";
  commitId: CommitId;
  createdAt: string;
  author: AuthorId;
};

type Operation = AddNodeOp | AddEdgeOp | SupersedeEdgeOp | CommitOp;
```

---

## 3) Policy (updated)

Policies now receive the full `GraphStore` for cross-graph validation.

```ts
type Violation = {
  code: string;
  message: string;
  path?: string;
};

type Policy = {
  // Single-graph operation validation (Graph-level immutability, author, etc.)
  validateOperation(store: GraphStore, graphId: GraphId, op: Operation): Violation[];

  // Whole-store validation (cross-graph edges, circular dependencies)
  validateStore(store: GraphStore): Violation[];
};
```

### ConstitutionalPolicy (v0.3)

Enforces all v0.2 constraints plus:

- `graphId` required and non-empty on `add_node`, `add_edge`, `supersede_edge`, `commit`
- Node ID / Edge ID / commitId uniqueness across the **entire GraphStore**
- Cross-graph edge resolution: both `from` and `to` **MUST** resolve within the GraphStore (`EDGE_NOT_RESOLVED`)
- Circular dependency detection across graph boundaries (`CIRCULAR_DEPENDENCY`)
- Per-Graph immutability after commit (unchanged from v0.2)

---

## 4) Kernel Interface (updated)

### apply / applyBatch

```ts
type KernelError = {
  kind: "PolicyViolation" | "UnknownOperation";
  violations?: Violation[];
  message?: string;
};

type ApplyEvent =
  | { type: "applied"; opType: Operation["type"] }
  | { type: "rejected"; opType: Operation["type"]; error: KernelError };

type ApplyResult = { store: GraphStore; events: ApplyEvent[] };  // Graph → GraphStore

function apply(
  store: GraphStore,
  graphId: GraphId,
  op: Operation,
  policy: Policy
): ApplyResult;

function applyBatch(
  store: GraphStore,
  graphId: GraphId,
  ops: Operation[],
  policy: Policy
): ApplyResult;
```

### lint

```ts
type LintResult = { ok: true } | { ok: false; violations: Violation[] };

// Lint a single Graph within the store
function lint(store: GraphStore, graphId: GraphId, policy: Policy): LintResult;

// Lint the entire GraphStore (cross-graph validation)
function lintStore(store: GraphStore, policy: Policy): LintResult;
```

### replay / replayAt

```ts
// Replay a sequence of (graphId, ops) pairs into a GraphStore
type GraphLog = { graphId: GraphId; ops: Operation[] };

function replay(logs: GraphLog[], policy: Policy): GraphStore;
function replayAt(logs: GraphLog[], commitId: string, policy: Policy): GraphStore;
```

### diff

```ts
type DiffResult = {
  addedNodes: string[];
  removedNodes: string[];
  addedEdges: string[];
  removedEdges: string[];
  changedNodes: string[];
  changedEdges: string[];
};

// Diff two GraphStores (cross-graph aware)
function diffStore(a: GraphStore, b: GraphStore): DiffResult;

// Diff two individual Graphs (unchanged from v0.2)
function diff(a: Graph, b: Graph): DiffResult;
```

### resolve (NEW in v0.3)

```ts
function resolveNode(store: GraphStore, id: NodeId): ResolvedNode | null;
function resolveEdge(store: GraphStore, id: EdgeId): ResolvedEdge | null;
```

---

## 5) Error Codes (updated)

| Code | Severity | Description |
|---|---|---|
| `AUTHOR_REQUIRED` | ERROR | author is missing or empty |
| `IMMUTABLE_AFTER_COMMIT` | ERROR | mutation attempted on committed Graph |
| `COMMIT_ID_DUP` | ERROR | commitId already exists in GraphStore |
| `EDGE_NOT_FOUND` | ERROR | oldEdgeId not found in owning Graph |
| `EDGE_NOT_RESOLVED` | ERROR | cross-graph edge endpoint cannot be resolved (NEW) |
| `CIRCULAR_DEPENDENCY` | ERROR | circular dependency detected within or across Graphs (NEW) |
| `GRAPH_ID_REQUIRED` | ERROR | graphId is missing or empty (NEW) |
| `GRAPH_ID_DUP` | ERROR | graphId already exists in GraphStore (NEW) |
| `NODE_ID_DUP` | ERROR | nodeId already exists in GraphStore (NEW: store-wide) |
| `EDGE_ID_DUP` | ERROR | edgeId already exists in GraphStore (NEW: store-wide) |

---

## 6) Backward Compatibility

A single-graph GraphStore is fully v0.2 compatible:

```ts
// v0.2 style (still valid in v0.3)
const store = emptyStore();
const result = applyBatch(store, "G:default" as GraphId, ops, policy);

// Equivalent to v0.2:
// applyBatch(emptyGraph(), ops, policy)
```

The only required migration step is adding `graphId` to each log file and `Graph` object.
All Node / Edge / Commit schemas and status vocabularies are unchanged.

