# DecisionGraph Core — Minimal Kernel API v0.2

**Normative Reference:** DecisionGraph Core Constitution v0.2
In case of conflict, the Constitution takes precedence.

This document describes the **current implementation surface** of `@decisiongraph/core`.

---

## Model Layers

- **Core Model (Normative):** Node / Edge / Status semantics are defined by the Constitution v0.2.
- **Kernel (Deterministic):** Applies operations to produce a graph state. The kernel does not “judge”.
- **Policy (Enforcement):** Constitutional requirements are enforced via `ConstitutionalPolicy` (and optionally additional policies).
- **Log Model (Transport):** A sequence of ops is used for replay/persistence (see JSON Schema v0.2).

---

## Design Principles

- Deterministic application: same inputs → same outputs
- No AI reasoning inside the kernel
- No random IDs generated by the kernel
- Constraints are explicit and enforceable (via policy)

---

## 1) Core Types (as implemented)

### IDs

- `NodeId`, `EdgeId`, `AuthorId`, `CommitId` are branded strings in TypeScript.
- ID generation is external to the kernel.

### Status

- `NodeStatus`: `"Active" | "Superseded" | "Deprecated"`
- `EdgeStatus`: `"Active" | "Superseded" | "Deprecated"`

> Note: Status vocabulary is part of the implementation surface.
> When serializing/deserializing, adapters may normalize values.

### Node / Edge / Commit

```ts
type Node = {
  id: NodeId;
  kind: string;
  status: "Active" | "Superseded" | "Deprecated";
  createdAt: string;   // ISO timestamp string
  author: AuthorId;
  payload?: unknown;
};

type Edge = {
  id: EdgeId;
  type: "depends_on" | "supports" | "refutes" | "overrides" | "supersedes";
  from: NodeId;
  to: NodeId;
  status: "Active" | "Superseded" | "Deprecated";
  createdAt: string;   // ISO timestamp string
  author: AuthorId;
  payload?: unknown;
};

type Commit = {
  commitId: CommitId;
  createdAt: string;   // ISO timestamp string
  author: AuthorId;
};

type Graph = {
  nodes: Record<string, Node>;
  edges: Record<string, Edge>;
  commits: Commit[];
};
```

---

## 2) Operations (as implemented)

All graph changes are expressed as operations.

```ts
type AddNodeOp = { type: "add_node"; node: Node };
type AddEdgeOp = { type: "add_edge"; edge: Edge };

type SupersedeEdgeOp = {
  type: "supersede_edge";
  oldEdgeId: EdgeId;
  newEdge: Edge;
};

type CommitOp = {
  type: "commit";
  commitId: CommitId;
  createdAt: string;
  author: AuthorId;
};

type Operation = AddNodeOp | AddEdgeOp | SupersedeEdgeOp | CommitOp;
```

---

## 3) Policy (Enforcement)

Policies validate operations and whole graphs.

```ts
type Violation = {
  code: string;
  message: string;
  path?: string;
};

type Policy = {
  validateOperation(graph: Graph, op: Operation): Violation[];
  validateGraph(graph: Graph): Violation[];
};
```

### ConstitutionalPolicy (current implementation)

`ConstitutionalPolicy` enforces key constitutional constraints at runtime, including:

- author required on `add_node`, `add_edge`, `supersede_edge`, `commit`

- after the first `commit`, mutation ops are rejected
- only a single `commit` is allowed; subsequent `commit` ops are rejected
- `node.id` / `edge.id` uniqueness is enforced for `add_node`, `add_edge`, `supersede_edge`
- `node.status`, `edge.status`, and `edge.type` vocabularies are enforced at runtime
- `supersede_edge` requires the old edge to exist and be `Active`, and the new edge to be `Active`

- `commitId` must be unique


---

## 4) Kernel Interface

### apply / applyBatch

```ts
type KernelError = {
  kind: "PolicyViolation" | "UnknownOperation";
  violations?: Violation[];
  message?: string;
};

type ApplyEvent =
  | { type: "applied"; opType: Operation["type"] }
  | { type: "rejected"; opType: Operation["type"]; error: KernelError };

type ApplyResult = { graph: Graph; events: ApplyEvent[] };

function apply(graph: Graph, op: Operation, policy: Policy): ApplyResult;
function applyBatch(graph: Graph, ops: Operation[], policy: Policy): ApplyResult;
```

- `apply` and `applyBatch` always enforce the Constitution first; caller policies can only add stricter rules.
- If any policy returns violations, the op is rejected and the graph is unchanged.

- Unknown op types are rejected.


### lint

```ts
type LintResult = { ok: true } | { ok: false; violations: Violation[] };

function lint(graph: Graph, policy: Policy): LintResult;
```

### replay / replayAt

```ts
function replay(ops: Operation[], policy: Policy): Graph;
function replayAt(ops: Operation[], commitId: string, policy: Policy): Graph;
```

- `replay` applies ops in order to an empty graph.

- `replayAt` replays until (and including) the matching `commitId`.


### diff

```ts
type DiffResult = {
  addedNodes: string[];
  removedNodes: string[];
  addedEdges: string[];
  removedEdges: string[];
  changedNodes: string[];
  changedEdges: string[];
};

function diff(a: Graph, b: Graph): DiffResult;
```

---

**Version:** 0.2
**Status:** Reference (implementation-aligned)
**Authority:** DecisionGraph Core Constitution v0.2
